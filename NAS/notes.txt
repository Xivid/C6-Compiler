//dealing with variables in nas
//fp frame pointer
//variables are unnamed 
//sp stack pointer is one address above the stack 


geti //get input and push on stack 
pop fp[0]

//local variables 
fp [-1]
//global variables 
sb[3] 

//for every function call
//local variable 2 fp[1] 
//local variable 1 fp[0]
//caller's pc fp [-1] program counter 
//caller's fp fp [-2]
//caller's sp fp [-3]
//caller's parameter 2 (by copy) fp[-4]
//caller's parameter 1 (by copy) fp[-5]


//after a call ,the fp rises by 3+param_n above the previous sp 
//the new sp is just at fp[0]
//sp rises with new push actions 
//the last push value is the return value at fp[0]after fp is restored 

//the pop instruction is actually pop the top of the stack and store

//adding DO WHILE 
DO stmt WHILE '('expr')' 

L001:
ex(stmt)
ex(expr)
j0 L002
jmp L001
L002:

//WHILE expr stmt
L001
expr
j0 L002
stmt
jmp L001
L002

continue jmp L001 
break jmp L002


//windows files have the /r problems 

//adding break and continue

FOR (stmt0 stmt1 stmt2 ) stmt3

stmt0 
while stmt1
{
	stmt3
	stmt2
}

//may execute assignment multiple times 
//the first one may be just a declaration but the second is just an assignment

//this can be optimized!
//push value
//push value 
//pop fp[0]

//the former version 
//if not defined 
push value
//else
push value
pop fp[0]

// is better with declarations 
